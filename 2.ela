import io;

/*  
  Note: for the sake of continuity in the tutorial, all of the code is within the main function.
  Types declared within functions are local to that scope.
  Impl's done within functions are propagated to the types that they affect.
  Typically, doing an impl in a function is not advised, as it hides behaviour.
  There are reasons it is allowed, which will be covered much later when we get to metaprogramming
  and compile time evaluation.
*/
fn main() {
  /* 
    Structs and other user defined types.

    structs are basically equivalent to C structs, with some minor quality of life improvements (default values for fields)

    structs have completely predictable layout, they are never reordered for efficiency by the compiler.
    they follow the same sizing and aligment conventions as the C ABI.
  */

  // declare a 2 member struct of floats that have default values of 1.0 unless overwritten by an aggregate initializer.
  struct Vec2 { x: f32 = 1.0, y: f32 = 1.0 }

  /* 
    while we'll cover choice types later (tagged unions), you can use anonymous sub-structs and
    unions to provide compatability with C libraries, as shown here:
  */

  union Vec2Union { 
    struct { x: f32, y: f32 },
    values: [f32; 2],
  }

  vec2union: Vec2Union = .{ x: 100.0, y: 100.0 };

  // we create a slice from the pointer so the formatter can reason about it's length. 
  // we can't pass arrays as function arguments in ela, they get implicitly casted to pointers and lose their length info.
  slice := [f32]::from(vec2union.values as *f32, 2);


  // When we print this, we can see that referring to 'values' points to the same memory as 
  // what was initialized with then .{x, y} literal.
  io::println(slice);


  // we can also use anonymous unions as subtypes of structs, 
  // say for a manually-implemented tagged union (again, we have a type that does this for you with pattern matching, but for C interop)

  // Enumerators in ela work just like C++, they're just named integers behind a type.
  // Theyre strongly typed compared to C, but same concept.
  enum UnionTag {
    Null,
    String,
    Integer,
  }

  struct TaggedUnion {
    tag: UnionTag,
    union {
      string: str,
      integer: u32
    }
  }

  mut tagged_union: TaggedUnion = .{
    string: "Hello, World!",
    tag: UnionTag::String,
  };


  /* 
    Now is probably a good time to talk about choice types.

    'choice' types are just tagged unions just like shown above, with some special syntax to make it alot easier and 
    much safer to use.

    here we'll declare a choice type 'value' that could be of several value types, just like 'TaggedUnion' above.
  */

  choice Value {
    Null, // this variant has no value, it's a marker variant.
    String(String), // this variant has one value of type String, unnamed.
    Integer { // this is a struct variant, which can have many named values.
      value: u64
    },
  }

  // Now, when we default-initialize a choice type, it's "discriminant" (the index of the occupied slot)
  // is placed to an invald value that points to none of the variants listed.
  // this is the one type in Ela that zero initialization effectively means garbage initialized, except
  // it is "zero'd", because we have no idea if the first field has data or not, so THAT would be garbage
  // initialization.
  mut v: Value;

  // We can use pattern matching to check the value in a choice type, much like Rust.
  // there is 'if $expr is $pattern' matching, and 'switch is $expr {  $pattern: {...} }' matching, which we'll cover later.

  // You don't need to actually extract any values to check against a discriminant, 
  // you can match against it as shown below as if it was a marker variant.
  if v is Value::Null {
    io::println("v was Value::Null (unexpected)");
  } else if v is Value::String {
    io::println("v was Value::String (unexpected)");
  } else if v is Value::Integer {
    io::println("v was Value::Integer (unexpected)");
  } else {
    io::println("v was Value::Uninitialized (expected)");
  }


  /*
    Now with that little caveat explained, let's get into actually using the choice type
    with values, and reading / writing to them.

    choice variant initialization depends on the variant kind:

    for markers, we just provide the name, as if we were referring to a type '::'     
  */

  v = Value::Null;

  if v is Value::Null {
    io::println("v was Value::Null, expected");
  }

  /* 
    for the 'tuple style', i.e those defined with the Variant(Type, Type...) including those with one value,
    we use a similar syntax to both initialize and fetch the values.
  */

  v = Value::String(String::from("Hello, choice type"));

  if v is Value::String(string) {
    io::printlnf("v was Value::String(\"%\")", (string,));
  }

  // We can also take pointers to these 'destructured' values, and declare them as mut, etc.

  if v is Value::String(mut string) {
    io::printlnf("v was Value::String(mut \"%\")", (string,));
  }

  if v is Value::String(&string) {
    io::printlnf("v was Value::String(    &ptr=%)", (string,));
  }

  if v is Value::String(&mut string) {
    io::printlnf("v was Value::String(&mut ptr=%)", (string,));
  }

  /* 
    So now, we can talk about the structs variants.

    They work very similar, just have a different construction an destructure syntax. they have the same
    memory semantics though
  */

  // initialization looks just like a normal struct.
  v = Value::Integer.{ value: 100 };

  // !! The dot is important here !! otherwise the parser couldn't tell if it's the block for the 'if' or not.
  // the left hand side of the colon is the name of the field in the struct variant 
  // that you're extracting from. it has to exist, of course

  // the right hand side of the colon is the variable you're declaring.
  // this is where you'd add 'mut $var', '&mut var', '&var', etc.
  if v is Value::Integer.{ value: extracted_value } {
    io::printlnf("v is Value::Integer {      value: % }", (extracted_value,));
  }

  if v is Value::Integer.{ value: mut extracted_value } {
    io::printlnf("v is Value::Integer { mut  value: % }", (extracted_value,));
  }

  if v is Value::Integer.{ value: &extracted_value } {
    io::printlnf("v is Value::Integer {     &value: % }", (extracted_value,));
  }

  if v is Value::Integer.{ value: &mut extracted_value } {
    io::printlnf("v is Value::Integer { &mut value: % }", (extracted_value,));
  }

  /* 
    The destructure lists for struct variants do not need to be exhaustive, you can cherry pick 
    whatever you want from them, or match nothing as we did when we were checking for the uninitialized variant.
  */

  /* 
    Unsafe access into choice variants:

    If you're 100% certain that a variant is present, and you don't want to pattern match for it because it 
    can get verbose especially when heavily nested, or when passed to a specific handler function for a certain
    variant type (say in an interpreter for AST nodes), you can just access it by type name with a member access.

    e.g {
      fn interpret_literal(ast: *AST) -> Value {
        * matching again here would be annoying if forced. ahem rust.
        return string_to_value(ast.Literal.value);
      }
      fn interpret(ast: *AST) -> Value {
        if ast is AST::Literal {
          interpret_literal(ast);
        }
      }
    }

    This is very unsafe though, because if the discriminant mismatches, or the data hasnt been properly initialized,
    reads and writes are undefined behaviour as you may be reading from or writing to some other variants data, 
    since unions share a block of memory for all subtypes.
  */

  // CAUTION: if the discriminant doesnâ€™t match, this is aliasing memory from another variant.
  // Thatâ€™s why you almost always want pattern matching instead.
  ch := Value::Integer.{value: 10};

  // we know ch is a Value::Integer, so we can pass the check and just print it.
  io::println(ch.Integer.value);


  /*  
    Traits

    traits (or more known as interfaces) are a way to define a set of behaviours for any type, provided via methods
    or associated functions ('static methods' for C like users.)

    They are very helpful in composing behaviour, and they have some interesting features. for Rust users, 
    this is all self explanatory, however we don't have quite as an expansive trait system as Rust.


    quickly before talking about how traits are actually defined and used, we'll talk about 'impl's. again, rust users
    can skim this, it's familiar.

    impl's are a way to add functions to any type. enums, scalars (s32, etc), structs, choice, and even other traits
    can have 'impl' applied to add functions. functions can be associated (not taking a self parameter) or be 'methods'
    which apply to a specific instance of an object. 

    here we'll add an associated function called 'one' and a method called 'halved' to Vec2 (previously defined above).

    impl functions have the same syntax generally as other functions.
  */

  // implementing functions for Vec2
  impl Vec2 {
    // we use the 'Self' keyword to refer to the type of whoever is implementing this, 
    // in this case it's concrete Vec2, but you'll see later why this is a smart convention.
    fn one() -> Self { 
      // we expect Vec2, so we don't need to specify the type for the aggregate initializer literal.
      return .{
        x: 1.0, 
        y: 1.0,
      };
    }

    /*  
      Now for our 'halved' method.

      ** self must be the first parameter, and you never need to specify its type, nor can you. **

      here we take 'self' by value, that is, a shallow copy.

      self parameters can vary as such:

      { self      -> by value. }
      { mut self  -> mutable locally, but by value. }
      { *self     -> pointer to self, immutable. }
      { *mut self -> pointer to self, mutable. }

    */
    fn halved(self) -> Self {
      // return a vector that represents self / 2.0;
      return .{
        x: self.x * 0.5,
        y: self.y * 0.5,
      };
    }

    // Just to demonstrate the calling semantics, we'll add some more methods, with the various 'self' semantics.
    fn zero_x(*mut self) {
      self.x = 0;
    }

    fn is_x_zero(*self) -> bool {
      return self.x == 0;
    }

    // Methods, and all functions, can have default parameters, which _do not have to be compile time constants_
    fn with_x_of(mut self, new_x: f32 = 100) -> Self {
      self.x = new_x;
      return self;
    }
  }

  // So now, lets look at calling some of these methods / associated functions.
  // we'll start with getting a unit Vec2 from the 'one' function.
  
  mut one := Vec2::one();
  io::println(one);


  // Now, since 'one' is an immutable variable, we can only call methods that arent '*mut self'.
  // 'mut self' (no pointer) is fine because it always takes a shallow copy and doesn't mutate the reciever.

  /* mut */ halved := one.halved();
  io::println(halved);

  halved_with_100_x := halved.with_x_of();
  io::println(halved_with_100_x);

  if halved_with_100_x.is_x_zero() {
    io::println("This isn't possible..");
  } else {
    io::println("'halved_with_100_x's X component was indeed not 0");
  }

  // to fix this, add mut to 'halved := ...'.
  halved.zero_x(); // !!! error! cannot call a '*mut self' method with an immutable variable, consider adding 'mut' to the declaration


  /* 
    Now with that covered, let's talk traits, since that just expands on this idea. 
    trait's are similar to impls, except they outline the template of what an impl needs to define,
    and creates a behavioural contract for any type that implements them.
  */

  // here we declare a contract that says whatever implements this has to have a to_string function that takes a *self and return a String
  trait ToString {
    fn to_string(*self) -> String;
  }

  t: ToString; // !!! error! You cannot have an instance of a 'trait' type -- it is sizeless and only used at compile time to enforce rules.

  // First, to use the trait, we have to implement it for something. let's do that here for Vec2.
  impl ToString for Vec2 {
    fn to_string(*self) -> String { // this signature has to match exactly! (some caveats to this will be covered later.)
      // for pretty much all types, format can handle this. this is just an example.
      // later we'll discuss fmt and writing custom formatters.
      return fmt::format("%", (*self,)); 
    }
  }

  // So now, on our Vec2, we can call get.
  halved_string := halved.to_string();
  io::printlnf("halved_string = %", (halved_string,));

  // Now, let's add some associated functions, through a different trait. 
  // But, we're going to require that anyone who implements our new trait, GetNegativeOne, 
  // has implemented HasGetFn already through a trait bounds, with this colon syntax

  // The semantics of anything following : are similar to 'where' clauses, meaning it can have comma seperated binding
  // expressions with '|' for 'or' and '&' for 'and', and of course it's not bitwise, they're logical relational expressions,
  // just differentiating.

  // We havent covered where clauses / statements yet, we'll do that later when we get into generics.
  trait DefaultString: ToString {
    // We can provide default implementations of methods and associated functions with traits.
    // it's kind of like 'virtual' functions in object oriented programming, except they can only be
    // used as a default, or implemented over.
    fn get_default_string() -> String {
      // default is an always-present stdlib function that just returns a default value for any type.
      _default := default!<Self>();
      // since we're bound to ToString, we can do this, since we know 'Self' implements 'to_string(*self)'.
      return _default.to_string();
    }
  }

  Vec2::get_default_string(); // !!! error! use of undeclared identifier 'get_default_string'

  // Just because we bound DefaultString to ToString, doesn't mean it's available to all implementers
  // of to ToString. In this case, we can just use an empty impl to add the default trait function.
  // Again, we _could_ implement it ourselves here, and it would just use our implementation over the default
  // one in the trait.
  impl DefaultString for Vec2 {}

  default_string := Vec2::get_default_string();
  // NOTE: We provided default values of { x: 1, y: 1 } in the struct declaration,
  // that's why this isnt { x: 0, y: 0 }
  io::printlnf("default_string = %", (default_string,));


  /* 
    Traits as return types implicitly being constraints within trait functions

    We can use traits as return type and parameter types in trait methods to just constrain whatever is supplied
    at implementation time to said trait.

    So, if we wanted a method or associated function to say take an Iterator and return an Iterator (which is a trait),
    we could do that, as long as when we 'impl' it, we provide a concrete type that's not a trait.
  */

  trait FilterIterator {
    fn filter_iter(iter: Iterator) -> Iterator;    
  }

  impl FilterIterator for Vec2 {
    // since Iter!<T> is our default iterator type for contiguous memory blocks, and 
    // it implements Iterator, this works. if we used a type that _didn't_ implement Iterator,
    // this would throw a compile time error.
    fn filter_iter(iter: Iter!<s32>) -> Iter!<s32> {
      return iter;
    }
  }

  /* 
    'dyn' trait objects

    for certain traits that pass the requirements, we can create 'dyn' (dynamic dispatch) instances of trait objects
    where it could be any type, as long as it implements the trait.

    'dyn' requirements are a bit strict, and the following requirements apply to any method within a trait that intends
    to be used as 'dyn':

    No associated functions:
      All functions in a 'dyn' compatible trait must be methods.
    
    No self by value:
      All methods must take a self, and it must take it by '*self' or '*mut self'

    No generic functions:
      No generic methods can be present in a dyn compatible trait. This doesn't mean that dyn traits cant be generic,
      it just means there cant be seperately generic functions within a dyn trait.

    No returning 'Self':
      You cannot return -> 'Self' or '*Self' at all, since we don't know the size of the type implementing it, and
      even if it was by pointer, it would have to be returned as '*void' because the actual instance type of a dyn
      object can vary at runtime.
  */

  /* 
    Creating 'dyn' instances:

    Any trait that satisfies the conditions for dyn is automatically able to be made into a dyn instance,
    as long as we provide a concrete type that implements it as well, and as a *mut.

    Since our ToString trait has an instance method that takes self by pointer and returns a type that's not
    'Self', it is dyn compatible, so let's make an instance of that, using Vec2.
  */

  // this is the syntax for naming a dyn type. just prefix with 'dyn'
  mut dyn_to_string: dyn ToString;

  // If we tried to call any methods on that default constructed dyn_to_string, we would segfault, because
  // the vtable is full of null pointers. it will never have defaults that are valid, so we use 'dynof'

  // since we know what 'dyn Trait' is expected, via the assignment to a typed variable, we can omit that
  // and just pass a mutable pointer to 'one' (a Vec2 from earlier in the tutorial)
  dyn_to_string = dynof(&mut one);

  // However, many times the compiler won't know what dyn trait is expected, and you can pass that as 
  // the second argument to dynof
  dyn_to_string = dynof(&mut one, ToString);

  // Now, we can perform any call we would like on the dyn_to_string, and it will dispatch to the instance types methods,
  // in this case Vec2.

  dyn_string_from_vec2 := dyn_to_string.to_string();
  io::printlnf("dyn_string_from_vec2 = %", (dyn_string_from_vec2,));

  // The thing about dyn's is that it can change the underlying type at any time during runtime.
  // this way, we can represent collections of objects of shared behaviour without needing some crazy generics

  // to show this we'll use s32 as another example implementer
  impl ToString for s32 {
    fn to_string(*self) -> String {
      return fmt::format("%", (*self,));
    }
  }

  mut s32_one: s32 = 1;
  dyn_to_string = dynof(&mut s32_one, ToString);
  dyn_string_from_s32 := dyn_to_string.to_string();
  io::printlnf("dyn_string_from_s32 = %", (dyn_string_from_s32,));

  // This concept is incredibly useful, and 'dyn' objects are essentially a struct { instance: *void, vtable: *void },
  // meaning they're always 16 bytes on 64 bit systems, so theyre rather cheap for how much you can get out of them.


  /* 
    Generics.

    Generics are a way to provide type arguments to a type or function, so it can vary in it's implementation per
    type provided. Most people are familiar with this.

    the generic syntax is always '!<>', for disambiguation reasons with expressions and clarity.

    A lot of the tutorial has used generics, since they're present all over in the stdlib, because theyre irreplacably useful.

    note: generic functions can infer generic arguments, so for a lot of these examples, you haven't even seen the generic arguments being passed.
  */

  // To start, we'll define a generic struct, Vector2, that takes a DataT type argument, which defines what it's interior value types will be.

  struct Vector2!<DataT> {
    x: DataT, // we just use the type parameter as if it was a type, because it is :D
    y: DataT
  }

  // Now, to instantiate this, it's just like a normal struct, except we'll provide a generic argument of 'f64' stating
  // we want x and y to be f64's.
  mut f64_vec2 := Vector2!<f64>.{ x: 0, y: 0 };

  // We'll make another one, for f32's.
  f32_vec2 := Vector2!<f32>.{ x: 0, y: 0 };

  f64_vec2 = f32_vec2; // !!! error! Type error in binary expression: cannot convert between Vector2!<f64> and Vector2!<f32>

  // each instantiation of a generic, that is, unique generic arguments provided to create it's concrete type,
  // is distinct and they are not convertible to each other.
  // this means if you wanted a List!<Vector2>, you would have to provide a concrete type such as Vector2!<s32>, 
  // otherwise it's unresolved and we don't know what you want.

  /* 
    Every type besides 'enum' is a candidate for generics.

    We'll talk about how generic impl's work, because it complicate things a bit:

    You can 'impl' on a generic type with a concrete set of generic arguments, such as
  */

  impl Vector2!<f32> {
    // ... some methods that are only available to Vector2!<f32> ...
    fn negative_one() -> Self {
      return .{
        x: -1,
        y: -1,
      }
    }
  }

  /*
    when using 'impl' on a generic type without proividing a concrete set of arguments,
    you have to do some extra work to fetch those arguments to provide to your target type.
    this is how we do that:
  */
  impl!<DataT> Vector2!<DataT> {
    // .. some methods or functions that are available to any Vector2 regardless of DataT ...
    fn zero() -> Self {
      return default!<Self>();
    }
  }

  // So now, we can do:
  zeroed_s32 := Vector2!<s32>::zero();
  io::printlnf("zeroed_s32 = %", (zeroed_s32,));

  negative_one_s32 := Vector2!<s32>::negative_one(); // !!! error! use of undeclared identifier 'negative_one'
  // We only provided 'negative_one' to Vector2!<f32>, so we cant use s32 and expect it to work.
  negative_one_f32 := Vector2!<f32>::negative_one();
  io::printlnf("negative_one_f32 = %", (negative_one_f32,));
}